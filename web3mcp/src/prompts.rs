use crate::types::*;
use rmcp::handler::server::wrapper::Parameters;
use rmcp::model::{PromptMessage, PromptMessageRole};
use rmcp::{prompt, prompt_router};

/// Prompt router (MCP Prompts) - reusable templates for LLM clients.
#[prompt_router]
impl crate::Web3McpServer {
    #[prompt(description = "Analyze an EVM address (suggested tool calls and checklist)")]
    pub async fn analyze_address(
        &self,
        Parameters(req): Parameters<PromptAnalyzeAddressRequest>,
    ) -> Vec<PromptMessage> {
        let chain_id = req.chain_id.unwrap_or(1);
        let addr = req.address;
        vec![PromptMessage::new_text(
            PromptMessageRole::User,
            format!(
                concat!(
                    "Analyze this EVM address on chain_id={}: {}.\n\n",
                    "1) Call evm_is_contract.\n",
                    "2) Call evm_get_native_balance.\n",
                    "3) If token_address provided, call evm_get_erc20_balance and evm_get_erc20_token_info.\n",
                    "4) Summarize results and flag anything suspicious (contract/EOA, low gas, etc.)."
                ),
                chain_id, addr
            ),
        )]
    }

    #[prompt(description = "Analyze an EVM transaction (receipt + logs + common failure reasons)")]
    pub async fn analyze_transaction(
        &self,
        Parameters(req): Parameters<PromptAnalyzeTransactionRequest>,
    ) -> Vec<PromptMessage> {
        let chain_id = req.chain_id.unwrap_or(1);
        let tx_hash = req.tx_hash;
        vec![PromptMessage::new_text(
            PromptMessageRole::User,
            format!(
                concat!(
                    "Analyze this EVM tx on chain_id={}: {}.\n\n",
                    "1) Call evm_get_transaction_receipt(include_receipt=true).\n",
                    "2) If it failed, classify likely cause using error_class/revert_reason patterns.\n",
                    "3) If logs are relevant, run evm_decode_transaction_receipt (if ABI available).\n",
                    "4) Summarize what happened and next steps."
                ),
                chain_id, tx_hash
            ),
        )]
    }

    #[prompt(description = "Analyze an ERC20 token (metadata + balances + allowance guidance)")]
    pub async fn analyze_token(
        &self,
        Parameters(req): Parameters<PromptAnalyzeTokenRequest>,
    ) -> Vec<PromptMessage> {
        let chain_id = req.chain_id.unwrap_or(1);
        let token = req.token_address;
        let owner = req.owner_address.unwrap_or_else(|| "".to_string());
        vec![PromptMessage::new_text(
            PromptMessageRole::User,
            format!(
                concat!(
                    "Analyze this ERC20 token on chain_id={}: {}.\n\n",
                    "1) Call evm_get_erc20_token_info.\n",
                    "2) If owner_address provided, call evm_get_erc20_balance.\n",
                    "3) If spender provided, call evm_erc20_allowance.\n",
                    "4) Summarize decimals-aware balances and any approval risk.\n\n",
                    "owner_address: {}"
                ),
                chain_id, token, owner
            ),
        )]
    }

    #[prompt(
        description = "Explain a common EVM concept (gas, nonce, approval, EIP-1559) in context"
    )]
    pub async fn explain_evm_concept(
        &self,
        Parameters(req): Parameters<PromptExplainEvmConceptRequest>,
    ) -> Vec<PromptMessage> {
        vec![PromptMessage::new_text(
            PromptMessageRole::User,
            format!(
                concat!(
                    "Explain the EVM concept: {}.\n",
                    "Keep it practical, mention common pitfalls, and connect it to the server safety model (pending/needs_confirmation)."
                ),
                req.concept
            ),
        )]
    }
}

impl crate::Web3McpServer {
    /// Public constructor for the prompt router (used by server initialization).
    pub fn build_prompt_router() -> rmcp::handler::server::router::prompt::PromptRouter<Self> {
        // This private function is generated by #[prompt_router].
        Self::prompt_router()
    }
}
